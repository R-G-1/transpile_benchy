"""QiskitInterface class.

This module contains the QiskitInterface class, which is a subclass of
SubmoduleInterface. It is intended to be used for submodules that are
written in Qiskit, and have a set of functions which return
QuantumCircuits.
"""
from typing import Callable, Dict, List, Type

from transpile_benchy.interfaces.abc_interface import SubmoduleInterface


class QiskitFunctionInterface(SubmoduleInterface):
    """Subclass of QiskitInterface with QuantumFunctionFactory integrated.

    This class encapsulates the process of generating Qiskit functions
    of a given type (e.g., QFT or QuantumVolume) for a specified set of
    qubit counts. The QuantumFunctionFactory nested class handles the
    generation of these functions.

    Example usage:

    num_qubits = [8, 12, 16, 20, 24, 28, 32, 36]

    qiskit_functions_qft = QiskitFunctionInterface(QFT, num_qubits)

    qiskit_functions_qv = QiskitFunctionInterface(QuantumVolume, num_qubits)
    """

    class QuantumFunctionFactory:
        """Factory for creating quantum functions.

        This factory generates Qiskit functions of a given type for a
        specific list of qubit counts. The generated functions can then
        be retrieved as a list through the generate_functions method.
        """

        def __init__(self, function_type: Type[Callable], num_qubits: List[int]):
            """Initialize QuantumFunctionFactory."""
            self.function_type = function_type
            self.num_qubits = num_qubits

        def generate_functions(self) -> Dict[str, Callable]:
            """Generate a dictionary of quantum functions."""
            return {
                # f"{self.function_type.__name__.lower()}_{n}": self._create_function(n)
                f"{self.function_type.__name__}": self._create_function(n)
                for n in self.num_qubits
            }

        def _create_function(self, num_qubits: int) -> Callable:
            """Create a quantum function given number of qubits."""
            func = self.function_type(num_qubits)
            # func.name = f"{self.function_type.__name__.lower()}_{num_qubits}"
            func.name = f"{self.function_type.__name__}"
            return func

    def __init__(self, function_type: Type[Callable], num_qubits: List[int]) -> None:
        """Initialize QiskitFunctionInterface."""
        self.function_factory = self.QuantumFunctionFactory(function_type, num_qubits)
        self.raw_circuits = self._get_quantum_circuits()

    def _get_quantum_circuits(self) -> List[Callable]:
        """Return functions generated by the QuantumFunctionFactory."""
        return list(self.function_factory.generate_functions().values())


# from qiskit.circuit.library import CXGate, iSwapGate
# from qiskit.extensions import UnitaryGate
# from weylchamber import canonical_gate
# from transpile_benchy.interfaces.qiskit_interface import QiskitFunctionInterface
# from qiskit.circuit.library import TwoLocal

# num_qubits = 8
# coupling_map = CouplingMap.from_line(num_qubits)
# # coupling_map = CouplingMap.from_grid(3, 3)


# def create_TwoLocal_function(
#     entanglement_blocks, entanglement_name, entanglement_type="full", reps=2
# ):
#     """Generates a function to create a TwoLocal object with given parameters"""

#     def TwoLocal_function(n_qubits):
#         return TwoLocal(n_qubits, "ry", entanglement_blocks, entanglement_type, reps)

#     TwoLocal_function.__name__ = (
#         # f"TwoLocal_{entanglement_type}_{entanglement_name}_{reps}reps"
#         f"TwoLocal-{entanglement_name}"
#     )
#     return TwoLocal_function


# def generate_interface_from_data(data, qubits_options):
#     """Generates a QiskitFunctionInterface from gate data and qubits options"""
#     gate, name = data
#     func = create_TwoLocal_function(gate, name)
#     return QiskitFunctionInterface(func, qubits_options)


# num_qubits_options = [num_qubits]  # Or any other options you'd like

# # Specify the gate blocks and their names
# entanglement_blocks_data = [
#     (CXGate(), r"$\texttt{CNOT}$"),
#     # (CXGate().power(1 / 2), r"$\sqrt{\texttt{CNOT}}$"),
#     (iSwapGate(), r"$\texttt{iSWAP}$"),
#     (iSwapGate().power(1 / 2), r"$\sqrt{\texttt{iSWAP}}$"),
#     (UnitaryGate(canonical_gate(0.5, 0.25, 0.25).full()), r"$\texttt{ECP}$"),
# ]

# qiskit_functions_twolocal = [
#     generate_interface_from_data(data, num_qubits_options)
#     for data in entanglement_blocks_data
# ]

# N = 5
# num_qubits = [N]  # , 20, 24, 28, 32, 36]
# from qiskit.circuit.library import QFT, QuantumVolume

# coupling_map = CouplingMap.from_line(N)
# coupling_map = CouplingMap.from_heavy_hex(5)
# qiskit_functions_qft = [QiskitFunctionInterface(QFT, num_qubits)]
# qiskit_functions_qv = [QiskitFunctionInterface(QuantumVolume, num_qubits)]
